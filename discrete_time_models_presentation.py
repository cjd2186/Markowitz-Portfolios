# -*- coding: utf-8 -*-
"""Discrete_Time_Models_Presentation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1J6itXZYXebA9v-b5Cjba45bKCnvkWJUS

# Problem:
Given a year of historical prices and returns, what is the optimal portfolio weights we can have for tomorrow? What do we even mean by "optimal?"
"""

#downloading packages

import yfinance as yf
import json
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
plt.style.use('fivethirtyeight')
from numpy.lib.stride_tricks import as_strided
import pandas_datareader as pdr
from google.colab import drive
from scipy.optimize import minimize
import datetime as datetime
from datetime import datetime as dt
import matplotlib.dates as mdates

#collecting tickers and historical data

tickers = ['NORD', 'MSFT', 'SBUX']

df_list = []
for ticker in tickers:
  print(ticker)
  prices = yf.download(ticker, start = '2023-04-24')
  prices = prices[['Adj Close']].rename(columns = {'Adj Close': ticker})
  df_list.append(prices)

df_prices = pd.concat(df_list, axis=1)

df_return = df_prices.pct_change()

df = pd.merge(df_prices, df_return, how='left', left_index = True, right_index = True, suffixes = ('','_prc'))
df = df.dropna(axis=0, how = 'any')

"""#Method 1: Minimize Volatility"""

# Calculate expected returns and covariance matrix

def min_var_weights(Cov, lb, ub):
  num_assets = len(Cov)


  def get_var(w):
    var = np.dot(w.T,np.dot(Cov,w))
    return var


  def risk_function(w):
    return get_var(w)

  def check_sum(w):
    return 1-np.sum(w)

  constraints = ({'type':'eq', 'fun':check_sum})

  w0 = np.array(num_assets * [1.0 / num_assets])
  bounds = ((lb,ub),)*num_assets


  w_opt = minimize(risk_function, w0, method = 'SLSQP', bounds = bounds, constraints=constraints)
  return w_opt.x

expected_returns = df_return.mean()
cov_matrix = df_return.cov()

min_variance_weights = min_var_weights(cov_matrix, -np.inf, np.inf)

# Display the optimal weights for the minimum variance portfolio
for asset, weight in zip(df_return.columns, min_variance_weights):
    print(f"{asset}: {weight:.4f}")

"""# Method 2: Minimize Volatility for a Given Expected Return"""

def min_var_for_returns(Cov, target_return, lb, ub):
  num_assets = len(Cov)


  def get_var(w):
    var = np.dot(w.T,np.dot(Cov,w))
    return var


  def risk_function(w):
    return get_var(w)

  def check_sum(w):
    return 1-np.sum(w)

  def constraint_for_target_return(w):
    portfolio_return = np.dot(w, expected_returns)
    return portfolio_return - target_return

  constraints = [{'type': 'eq', 'fun': check_sum},
                 {'type': 'eq', 'fun': constraint_for_target_return}]

  w0 = np.array(num_assets * [1.0 / num_assets])
  bounds = ((lb,ub),)*num_assets


  w_opt = minimize(risk_function, w0, method = 'SLSQP', bounds = bounds, constraints=constraints)
  return w_opt.x

def plot_efficient_frontier(cov_matrix, expected_returns, lb, ub, num_points):

    min_return = 0
    max_return = np.max(expected_returns)
    target_returns = np.linspace(min_return, max_return, num_points)
    risks = []
    returns = []


    for target_return in target_returns:
        optimal_weights = min_var_for_returns(cov_matrix, target_return, lb, ub)
        expected_portfolio_return = np.dot(optimal_weights, expected_returns)
        portfolio_variance = np.dot(optimal_weights.T, np.dot(cov_matrix, optimal_weights))
        portfolio_risk = np.sqrt(portfolio_variance)
        risks.append(portfolio_risk)
        returns.append(expected_portfolio_return)


    plt.figure(figsize=(10, 6))
    plt.scatter(risks, returns, color='blue', label='Efficient Frontier')
    plt.xlabel('Risk (Standard Deviation)')
    plt.ylabel('Return (Daily)')
    plt.title('Efficient Frontier')
    plt.legend()
    plt.grid(True)
    plt.show()


plot_efficient_frontier(cov_matrix, expected_returns, lb=-np.inf, ub=np.inf, num_points=9)

"""This is known as the efficient fronteir.

# Method 3: Find the Maximum Sharpe Portfolio

We can solve another constraint problem to find the ideal portfolio along this curve.
"""

def get_max_sharpe(mu, Cov, rf, lb, ub):
  num_assets = len(mu)
  rf = np.exp(rf/252)-1

  def get_sharpe(w):
    sigma = np.sqrt((np.dot(w.T,np.dot(Cov,w))))
    r = np.sum(mu*w)
    return (r-rf)/sigma

  def risk_function(w):
    return -get_sharpe(w)

  def check_sum(w):
    return 1-np.sum(w)

  constraints = ({'type':'eq', 'fun':check_sum})

  w0 = np.array(num_assets * [1.0 / num_assets])
  bounds = ((lb,ub),)*num_assets


  w_opt = minimize(risk_function, w0, method = 'SLSQP', bounds = bounds, constraints=constraints)
  return w_opt.x

max_sharpe_weights = get_max_sharpe(expected_returns, cov_matrix, 0, -np.inf, np.inf)

for asset, weight in zip(df_return.columns, max_sharpe_weights):
    print(f"{asset}: {weight:.4f}")

def plot_efficient_frontier(cov_matrix, expected_returns, rf, lb, ub, num_points):

    min_return = 0
    max_return = 0.01
    target_returns = np.linspace(min_return, max_return, num_points)
    risks = []
    returns = []


    for target_return in target_returns:
      optimal_weights = min_var_for_returns(cov_matrix, target_return, lb, ub)
      expected_portfolio_return = np.dot(optimal_weights, expected_returns)
      portfolio_variance = np.dot(optimal_weights.T, np.dot(cov_matrix, optimal_weights))
      portfolio_risk = np.sqrt(portfolio_variance)
      risks.append(portfolio_risk)
      returns.append(expected_portfolio_return)

    optimal_weights = get_max_sharpe(expected_returns, cov_matrix, rf, lb, ub)
    expected_portfolio_return = np.dot(optimal_weights, expected_returns)
    portfolio_variance = np.dot(optimal_weights.T, np.dot(cov_matrix, optimal_weights))
    portfolio_risk = np.sqrt(portfolio_variance)




    plt.figure(figsize=(10, 6))
    plt.scatter(risks, returns, color='blue', label='Efficient Frontier')
    plt.scatter(portfolio_risk, expected_portfolio_return, color = 'red', label = "Optimal Sharpe Ratio")
    plt.xlabel('Risk (Standard Deviation)')
    plt.ylabel('Return (Daily)')
    plt.title('Efficient Frontier')
    plt.legend()
    plt.grid(True)
    plt.show()


plot_efficient_frontier(cov_matrix, expected_returns, 0, lb=-np.inf, ub=np.inf, num_points=50)

def get_sharpe(w, mu, Cov, rf):
  rf = np.exp(rf/252)-1
  sigma = np.sqrt((np.dot(w.T,np.dot(Cov,w))))
  r = np.sum(mu*w)
  return (r-rf)/sigma

even_weights = np.array(len(tickers) * [1.0 / len(tickers)])
mk_weights = get_max_sharpe(expected_returns, cov_matrix,0, -np.inf,np.inf)
mk_sharpe = get_sharpe(mk_weights, expected_returns, cov_matrix, 0)
even_sharpe = get_sharpe(even_weights, expected_returns, cov_matrix, 0)
print(f"Tangency Portfolio Daily Sharpe: {mk_sharpe:.4f}")
print(f"Even Weights Portfolio Daily Sharpe: {even_sharpe:.4f}")